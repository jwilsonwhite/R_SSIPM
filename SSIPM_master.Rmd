---
title: "SSIPM_master"
author: "Will White"
date: '2023-01-10'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

# SSIPM Code for Nickols et al. SONGS artificial reefs project
# Author: Will White
# Based on code in White et al. 2016 Ecol Appl and subsequent modifications

# Base code will just estimate F and R for a single site...extensions/modifications as needed

```{r}
# load necessary libraries (including eventually the SSIPM library)
# library(tidyverse)
library(tidyr)
library(dplyr)
library(ggplot2)
library(readr)
library(purrr)
library(tibble)
library(stringr)
library(forcats)
#library for inverse gamma
library(invgamma)

library(here)
source(here("SSIPM","calculate.prior.R"))
source(here("SSIPM","create.params.R"))
source(here("SSIPM","fit.SSIPM.MCMC.R"))
source(here("SSIPM","get.cand.R"))
source(here("SSIPM","kernmat.R"))
source(here("SSIPM","run.IPM.R"))
```

```{r}
# Read in data
# This will work best if the data are arranged as abundance in each length bin on the rows, with a column for each annual observation. Missing years should be a column of NAs

{

{
inUrl1  <- "https://pasta.lternet.edu/package/data/eml/edi/668/3/60afbd5190f50ba5271dacdf74e549f3" 
infile1 <- tempfile()
try(download.file(inUrl1,infile1,method="curl"))
if (is.na(file.size(infile1))) download.file(inUrl1,infile1,method="auto")

                   
 dt1 <-read.csv(infile1,header=F 
          ,skip=1
            ,sep=","  
        , col.names=c(
                    "year",     
                    "date",     
                    "reef_code",     
                    "polygon",     
                    "phase_built_code",     
                    "transect_code",     
                    "visibility",     
                    "species_code",     
                    "genus_name",     
                    "species_name",     
                    "count",     
                    "total_length",     
                    "total_area_sampled"    ), check.names=TRUE)
               
unlink(infile1)
		    
# Fix any interval or ratio columns mistakenly read in as nominal and nominal columns read as numeric or dates read as strings
                
if (class(dt1$date)!="factor") dt1$date<- as.factor(dt1$date)
if (class(dt1$reef_code)!="factor") dt1$reef_code<- as.factor(dt1$reef_code)
if (class(dt1$polygon)!="factor") dt1$polygon<- as.factor(dt1$polygon)
if (class(dt1$phase_built_code)!="factor") dt1$phase_built_code<- as.factor(dt1$phase_built_code)
if (class(dt1$transect_code)!="factor") dt1$transect_code<- as.factor(dt1$transect_code)
if (class(dt1$visibility)=="factor") dt1$visibility <-as.numeric(levels(dt1$visibility))[as.integer(dt1$visibility) ]               
if (class(dt1$visibility)=="character") dt1$visibility <-as.numeric(dt1$visibility)
if (class(dt1$species_code)!="factor") dt1$species_code<- as.factor(dt1$species_code)
if (class(dt1$genus_name)!="factor") dt1$genus_name<- as.factor(dt1$genus_name)
if (class(dt1$species_name)!="factor") dt1$species_name<- as.factor(dt1$species_name)
if (class(dt1$count)=="factor") dt1$count <-as.numeric(levels(dt1$count))[as.integer(dt1$count) ]               
if (class(dt1$count)=="character") dt1$count <-as.numeric(dt1$count)
if (class(dt1$total_length)=="factor") dt1$total_length <-as.numeric(levels(dt1$total_length))[as.integer(dt1$total_length) ]               
if (class(dt1$total_length)=="character") dt1$total_length <-as.numeric(dt1$total_length)
if (class(dt1$total_area_sampled)=="factor") dt1$total_area_sampled <-as.numeric(levels(dt1$total_area_sampled))[as.integer(dt1$total_area_sampled) ]               
if (class(dt1$total_area_sampled)=="character") dt1$total_area_sampled <-as.numeric(dt1$total_area_sampled)
                
# Convert Missing Values to NA for non-dates
                
dt1$date <- as.factor(ifelse((trimws(as.character(dt1$date))==trimws("-99999")),NA,as.character(dt1$date)))
dt1$reef_code <- as.factor(ifelse((trimws(as.character(dt1$reef_code))==trimws("-99999")),NA,as.character(dt1$reef_code)))
dt1$polygon <- as.factor(ifelse((trimws(as.character(dt1$polygon))==trimws("-99999")),NA,as.character(dt1$polygon)))
dt1$phase_built_code <- as.factor(ifelse((trimws(as.character(dt1$phase_built_code))==trimws("-99999")),NA,as.character(dt1$phase_built_code)))
dt1$transect_code <- as.factor(ifelse((trimws(as.character(dt1$transect_code))==trimws("-99999")),NA,as.character(dt1$transect_code)))
dt1$visibility <- ifelse((trimws(as.character(dt1$visibility))==trimws("-99999")),NA,dt1$visibility)               
suppressWarnings(dt1$visibility <- ifelse(!is.na(as.numeric("-99999")) & (trimws(as.character(dt1$visibility))==as.character(as.numeric("-99999"))),NA,dt1$visibility))
dt1$species_code <- as.factor(ifelse((trimws(as.character(dt1$species_code))==trimws("-99999")),NA,as.character(dt1$species_code)))
dt1$genus_name <- as.factor(ifelse((trimws(as.character(dt1$genus_name))==trimws("-99999")),NA,as.character(dt1$genus_name)))
dt1$species_name <- as.factor(ifelse((trimws(as.character(dt1$species_name))==trimws("-99999")),NA,as.character(dt1$species_name)))
dt1$count <- ifelse((trimws(as.character(dt1$count))==trimws("-99999")),NA,dt1$count)               
suppressWarnings(dt1$count <- ifelse(!is.na(as.numeric("-99999")) & (trimws(as.character(dt1$count))==as.character(as.numeric("-99999"))),NA,dt1$count))
dt1$total_length <- ifelse((trimws(as.character(dt1$total_length))==trimws("-99999")),NA,dt1$total_length)               
suppressWarnings(dt1$total_length <- ifelse(!is.na(as.numeric("-99999")) & (trimws(as.character(dt1$total_length))==as.character(as.numeric("-99999"))),NA,dt1$total_length))
dt1$total_area_sampled <- ifelse((trimws(as.character(dt1$total_area_sampled))==trimws("-99999")),NA,dt1$total_area_sampled)               
suppressWarnings(dt1$total_area_sampled <- ifelse(!is.na(as.numeric("-99999")) & (trimws(as.character(dt1$total_area_sampled))==as.character(as.numeric("-99999"))),NA,dt1$total_area_sampled))


# Here is the structure of the input data frame:
str(dt1)                            
attach(dt1)                            
# The analyses below are basic descriptions of the variables. After testing, they should be replaced.                 

summary(year)
summary(date)
summary(reef_code)
summary(polygon)
summary(phase_built_code)
summary(transect_code)
summary(visibility)
summary(species_code)
summary(genus_name)
summary(species_name)
summary(count)
summary(total_length)
summary(total_area_sampled) 
                # Get more details on character variables
                 
summary(as.factor(dt1$date)) 
summary(as.factor(dt1$reef_code)) 
summary(as.factor(dt1$polygon)) 
summary(as.factor(dt1$phase_built_code)) 
summary(as.factor(dt1$transect_code)) 
summary(as.factor(dt1$species_code)) 
summary(as.factor(dt1$genus_name)) 
summary(as.factor(dt1$species_name))
detach(dt1)               
        

  phase2_3 <- dt1 %>% 
    filter(species_code %in% c("PACL", "OXCA", "PANE",
                               "CHPU", "EMJA", "SEPU")) 
} #phase 2 & 3 data from public repository
{
  
  condpath <- here("data","songs") 
  files <- dir(path = condpath,
               pattern = ".csv",
               full.names = TRUE)
  songs_1 <- files %>% #iterating over files
    set_names(nm = files) %>% # set the id for everything in "files"
    map_df(read_csv, .id = "filename") %>% 
    mutate(polygon = as.factor(polygon))
  } #add phase 1 data from data folder

  years <- data.frame(year = c(2000:2022))
  songs <- bind_rows(songs_1,phase2_3) %>% 
    select(3:18) 
  songs <- left_join(years, songs)
}

#get total count - values from Phase 1 ONLY, Bottom transect
songstotal <- songs %>% 
  filter(phase_built_code == "E", 
         transtype_strata %in% c("BOTTOM",NA)) %>% 
  summarise(tot_count = sum(count), .by = c(year, reef_code, species_code, total_length )) %>%
  drop_na(total_length) %>% 
  pivot_wider(names_from = year,values_from = tot_count) %>% 
  drop_na() %>% 
  filter(reef_code == "WNR") #data from one site

#filter one species 
fishtotal <- songstotal[which(songstotal$species_code == "SEPU"),] 

#get maximum length of fish surveyed
total_length <- data.frame("total_length" =  as.numeric(c(1:max(fishtotal$total_length))))

#arrange to have a row for every size bin (1cm increment)
fishtotal <- fishtotal %>% full_join(.,total_length) %>% 
  filter(total_length %in% c(1:max(fishtotal$total_length))) %>% 
  arrange(total_length) %>% 
  select(4:length(fishtotal)) %>% 
  replace(is.na(.),0) %>% #add NA
  add_column("2008" = NA, "2007" = NA) %>% 
  relocate(c("2007","2008"), .after = "2006") 

```

```{r}
#Define the number of transects and total area surveyed
transect <- songs %>% 
  filter(species_code == "SEPU") %>% 
  filter(transtype_strata %in% c("BOTTOM",NA),
         phase_built_code == "E") %>% #Using Bottom survey and Phase 1 reef
  drop_na(transect_code) %>% 
  pivot_wider(names_from = total_length,
              values_from = count) %>% 
  summarise(tot_transect = length(transect_code),
            .by = c(year, reef_code, total_area_sampled)) %>% 
  filter(reef_code %in% 'WNR') %>%  #Use only data from one site
  mutate(tot_area = total_area_sampled*tot_transect) %>% 
  summarise(tot_area = sum(tot_area),
            .by = c(year,reef_code)) %>% 
  select(c(year,tot_area)) %>% 
  pivot_wider(names_from = year,
              values_from = tot_area) %>%   
  add_column("2008" = NA, "2007" = NA) %>% 
  relocate(c("2007","2008"), .after = "2006") 
transect <- as.matrix(transect)
```

```{r}
#Define the phase of AR construction and year (to eventually identify years of AR expansion & fishing regulation)
years <- years
datyr <- c(1:dim(fishtotal)[2])
phase <- c(rep("P1",9),rep("P2",11),rep("P3",dim(fishtotal)[2]-20))

ar.phase <- cbind(years, datyr,phase)

```

```{r}
# Define the species to be examined and generate a list of fixed demographic parameters and IPM attributes/metadata
Sp <- 'SEPU'
meshsize = 100
MCMClen = 100 # how long are MCMC chains
MCMCchains = 3 # how many chains

# we may be missing a few necessary parameters in create.params()...add in as needed
fix.param <- create.params(Sp = Sp, meshsize =  meshsize, MCMClen = MCMClen,MCMCchains = MCMCchains) # fix.param will be handy to pass around arguments to other functions
fix.param$correction <- transect #add survey correction to fix.params
# fix.param$Ivec <- size_stbstate$stbstate # specify initial immigration size distribution
```

```{r}
# Set the priors for the parameters to be estimated...this list will need to be adjusted depending on the exact nature of the fitting we are doing
# for both recruitment & fishing is best done as lognormal.

R.mean <- log(10) # recruitment
R.sd <- 1
Im.mean <- log(10) #immigration
Im.sd <- 1
F.mean <- log(0.2) # fishing
F.sd <- 0.1
error.mean = 2 # process error shape
error.sd = 1 # process error scale

Names <- c(paste0("r",c(0:dim(fishtotal)[2])), "Im",'F','error') # for now assume one burn-in recruitment rate, three years of observations, and one harvest rate, and one process error term

Means <- abs(c(rep(R.mean,dim(fishtotal)[2]+1), Im.mean ,F.mean,error.mean)) #can't have negative fishing or recruitment
SDs <- c(rep(R.sd,dim(fishtotal)[2]+1), Im.sd,F.sd,error.sd)
# Type <- rep('lognormal', length(Means))
Type <- c(rep('lognormal',dim(fishtotal)[2]+1), "lognormal",
          "lognormal", "invgamma") #type for recruitment, immigration, fishing, and process error

Prior <- list(Names,Means,SDs,Type)
names(Prior) <- c('Names','Means','SDs','Type')
```

```{r}
# Setup things for fitting via MCMC
Fit <- fit.SSIPM.MCMC(fix.param,fishtotal,Prior,'mc_str_ar_P_A.RData', burnin.im = FALSE,burnin.r = FALSE)
# save the results...
```

```{r}
#post-processing the chains (work in progress)
Post.fit <- postproc.MCMC(Fit,fix.param) # combine chains & do diagnostic checks

```

```{r}
# Examine the prior
hist(Post.fit$F)

```

```{r}
#Posterior predictive checks (still in progress)
```
