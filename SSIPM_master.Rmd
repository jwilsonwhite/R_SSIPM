---
title: "SSIPM_master"
author: "Will White"
date: '2023-01-10'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

# SSIPM Code for Nickols et al. SONGS artificial reefs project
# Author: Will White
# Based on code in White et al. 2016 Ecol Appl and subsequent modifications

# Base code will just estimate F and R for a single site...extensions/modifications as needed

```{r}
# load necessary libraries (including eventually the SSIPM library)
# library(tidyverse)
library(tidyr)
library(dplyr)
library(ggplot2)
library(readr)
library(purrr)
library(tibble)
library(stringr)
library(forcats)
#library for inverse gamma
library(invgamma)

library(here)
source(here("SSIPM","calculate.prior.R"))
source(here("SSIPM","create.params.R"))
source(here("SSIPM","fit.SSIPM.MCMC.R"))
source(here("SSIPM","get.cand.R"))
source(here("SSIPM","kernmat.R"))
source(here("SSIPM","run.IPM.R"))
source(here("SSIPM","postproc.MCMC.R"))
```

```{r}
# Read in data
# This will work best if the data are arranged as abundance in each length bin on the rows, with a column for each annual observation. Missing years should be a column of NAs

{

{
inUrl1  <- "https://pasta.lternet.edu/package/data/eml/edi/668/3/60afbd5190f50ba5271dacdf74e549f3" 
infile1 <- tempfile()
try(download.file(inUrl1,infile1,method="curl"))
if (is.na(file.size(infile1))) download.file(inUrl1,infile1,method="auto")

                   
 dt1 <-read.csv(infile1,header=F 
          ,skip=1
            ,sep=","  
        , col.names=c(
                    "year",     
                    "date",     
                    "reef_code",     
                    "polygon",     
                    "phase_built_code",     
                    "transect_code",     
                    "visibility",     
                    "species_code",     
                    "genus_name",     
                    "species_name",     
                    "count",     
                    "total_length",     
                    "total_area_sampled"    ), check.names=TRUE)
               
unlink(infile1)
		    
# Fix any interval or ratio columns mistakenly read in as nominal and nominal columns read as numeric or dates read as strings
                
if (class(dt1$date)!="factor") dt1$date<- as.factor(dt1$date)
if (class(dt1$reef_code)!="factor") dt1$reef_code<- as.factor(dt1$reef_code)
if (class(dt1$polygon)!="factor") dt1$polygon<- as.factor(dt1$polygon)
if (class(dt1$phase_built_code)!="factor") dt1$phase_built_code<- as.factor(dt1$phase_built_code)
if (class(dt1$transect_code)!="factor") dt1$transect_code<- as.factor(dt1$transect_code)
if (class(dt1$visibility)=="factor") dt1$visibility <-as.numeric(levels(dt1$visibility))[as.integer(dt1$visibility) ]               
if (class(dt1$visibility)=="character") dt1$visibility <-as.numeric(dt1$visibility)
if (class(dt1$species_code)!="factor") dt1$species_code<- as.factor(dt1$species_code)
if (class(dt1$genus_name)!="factor") dt1$genus_name<- as.factor(dt1$genus_name)
if (class(dt1$species_name)!="factor") dt1$species_name<- as.factor(dt1$species_name)
if (class(dt1$count)=="factor") dt1$count <-as.numeric(levels(dt1$count))[as.integer(dt1$count) ]               
if (class(dt1$count)=="character") dt1$count <-as.numeric(dt1$count)
if (class(dt1$total_length)=="factor") dt1$total_length <-as.numeric(levels(dt1$total_length))[as.integer(dt1$total_length) ]               
if (class(dt1$total_length)=="character") dt1$total_length <-as.numeric(dt1$total_length)
if (class(dt1$total_area_sampled)=="factor") dt1$total_area_sampled <-as.numeric(levels(dt1$total_area_sampled))[as.integer(dt1$total_area_sampled) ]               
if (class(dt1$total_area_sampled)=="character") dt1$total_area_sampled <-as.numeric(dt1$total_area_sampled)
                
# Convert Missing Values to NA for non-dates
                
dt1$date <- as.factor(ifelse((trimws(as.character(dt1$date))==trimws("-99999")),NA,as.character(dt1$date)))
dt1$reef_code <- as.factor(ifelse((trimws(as.character(dt1$reef_code))==trimws("-99999")),NA,as.character(dt1$reef_code)))
dt1$polygon <- as.factor(ifelse((trimws(as.character(dt1$polygon))==trimws("-99999")),NA,as.character(dt1$polygon)))
dt1$phase_built_code <- as.factor(ifelse((trimws(as.character(dt1$phase_built_code))==trimws("-99999")),NA,as.character(dt1$phase_built_code)))
dt1$transect_code <- as.factor(ifelse((trimws(as.character(dt1$transect_code))==trimws("-99999")),NA,as.character(dt1$transect_code)))
dt1$visibility <- ifelse((trimws(as.character(dt1$visibility))==trimws("-99999")),NA,dt1$visibility)               
suppressWarnings(dt1$visibility <- ifelse(!is.na(as.numeric("-99999")) & (trimws(as.character(dt1$visibility))==as.character(as.numeric("-99999"))),NA,dt1$visibility))
dt1$species_code <- as.factor(ifelse((trimws(as.character(dt1$species_code))==trimws("-99999")),NA,as.character(dt1$species_code)))
dt1$genus_name <- as.factor(ifelse((trimws(as.character(dt1$genus_name))==trimws("-99999")),NA,as.character(dt1$genus_name)))
dt1$species_name <- as.factor(ifelse((trimws(as.character(dt1$species_name))==trimws("-99999")),NA,as.character(dt1$species_name)))
dt1$count <- ifelse((trimws(as.character(dt1$count))==trimws("-99999")),NA,dt1$count)               
suppressWarnings(dt1$count <- ifelse(!is.na(as.numeric("-99999")) & (trimws(as.character(dt1$count))==as.character(as.numeric("-99999"))),NA,dt1$count))
dt1$total_length <- ifelse((trimws(as.character(dt1$total_length))==trimws("-99999")),NA,dt1$total_length)               
suppressWarnings(dt1$total_length <- ifelse(!is.na(as.numeric("-99999")) & (trimws(as.character(dt1$total_length))==as.character(as.numeric("-99999"))),NA,dt1$total_length))
dt1$total_area_sampled <- ifelse((trimws(as.character(dt1$total_area_sampled))==trimws("-99999")),NA,dt1$total_area_sampled)               
suppressWarnings(dt1$total_area_sampled <- ifelse(!is.na(as.numeric("-99999")) & (trimws(as.character(dt1$total_area_sampled))==as.character(as.numeric("-99999"))),NA,dt1$total_area_sampled))


# Here is the structure of the input data frame:
str(dt1)                            
attach(dt1)                            
# The analyses below are basic descriptions of the variables. After testing, they should be replaced.                 

summary(year)
summary(date)
summary(reef_code)
summary(polygon)
summary(phase_built_code)
summary(transect_code)
summary(visibility)
summary(species_code)
summary(genus_name)
summary(species_name)
summary(count)
summary(total_length)
summary(total_area_sampled) 
                # Get more details on character variables
                 
summary(as.factor(dt1$date)) 
summary(as.factor(dt1$reef_code)) 
summary(as.factor(dt1$polygon)) 
summary(as.factor(dt1$phase_built_code)) 
summary(as.factor(dt1$transect_code)) 
summary(as.factor(dt1$species_code)) 
summary(as.factor(dt1$genus_name)) 
summary(as.factor(dt1$species_name))
detach(dt1)               
        

  phase2_3 <- dt1 %>% 
    filter(species_code %in% c("PACL", "OXCA", "PANE",
                               "CHPU", "EMJA", "SEPU")) 
} #phase 2 & 3 data from public repository
{
  
  condpath <- here("data","songs") 
  files <- dir(path = condpath,
               pattern = ".csv",
               full.names = TRUE)
  songs_1 <- files %>% #iterating over files
    set_names(nm = files) %>% # set the id for everything in "files"
    map_df(read_csv, .id = "filename") %>% 
    mutate(polygon = as.factor(polygon))
  } #add phase 1 data from data folder

  years <- data.frame(year = c(2000:2022))
  songs <- bind_rows(songs_1,phase2_3) %>% 
    select(3:18) 
  songs <- left_join(years, songs)
}

#get total count - values from Phase 1 ONLY, Bottom transect
songstotal <- songs %>% 
  filter(phase_built_code == "E", 
         transtype_strata %in% c("BOTTOM",NA)) %>% 
  summarise(tot_count = sum(count), .by = c(year, reef_code, species_code, total_length )) %>%
  drop_na(total_length) %>% 
  pivot_wider(names_from = year,values_from = tot_count) %>% 
  drop_na() %>% 
  filter(reef_code == "WNR") #data from one site

#filter one species 
fishtotal <- songstotal[which(songstotal$species_code == "SEPU"),] 

#get maximum length of fish surveyed
total_length <- data.frame("total_length" =  as.numeric(c(1:max(fishtotal$total_length))))

#arrange to have a row for every size bin (1cm increment)
fishtotal <- fishtotal %>% full_join(.,total_length) %>% 
  filter(total_length %in% c(1:max(fishtotal$total_length))) %>% 
  arrange(total_length) %>% 
  select(4:length(fishtotal)) %>% 
  replace(is.na(.),0) %>% #add NA
  add_column("2008" = NA, "2007" = NA) %>% 
  relocate(c("2007","2008"), .after = "2006") 

```

```{r}
#Define the number of transects and total area surveyed
transect <- songs %>% 
  filter(species_code == "SEPU") %>% 
  filter(transtype_strata %in% c("BOTTOM",NA),
         phase_built_code == "E") %>% #Using Bottom survey and Phase 1 reef
  drop_na(transect_code) %>% 
  pivot_wider(names_from = total_length,
              values_from = count) %>% 
  summarise(tot_transect = length(transect_code),
            .by = c(year, reef_code, total_area_sampled)) %>% 
  filter(reef_code %in% 'WNR') %>%  #Use only data from one site
  mutate(tot_area = total_area_sampled*tot_transect) %>% 
  summarise(tot_area = sum(tot_area),
            .by = c(year,reef_code)) %>% 
  select(c(year,tot_area)) %>% 
  pivot_wider(names_from = year,
              values_from = tot_area) %>%   
  add_column("2008" = NA, "2007" = NA) %>% 
  relocate(c("2007","2008"), .after = "2006") 
transect <- as.matrix(transect)
```

```{r}
#Define the phase of AR construction and year (to eventually identify years of AR expansion & fishing regulation)
years <- years
datyr <- c(1:dim(fishtotal)[2])
phase <- c(rep("P1",9),rep("P2",11),rep("P3",dim(fishtotal)[2]-20))

ar.phase <- cbind(years, datyr,phase)

```

```{r}
# Define the species to be examined and generate a list of fixed demographic parameters and IPM attributes/metadata
Sp <- 'SEPU'
meshsize = 100
MCMClen = 10^5 # how long are MCMC chains
MCMCchains = 3 # how many chains

# we may be missing a few necessary parameters in create.params()...add in as needed
fix.param <- create.params(Sp = Sp, meshsize =  meshsize, MCMClen = MCMClen,MCMCchains = MCMCchains) # fix.param will be handy to pass around arguments to other functions
fix.param$correction <- transect #add survey correction to fix.params
# fix.param$Ivec <- size_stbstate$stbstate # specify initial immigration size distribution
```


```{r}
# Set the priors for the parameters to be estimated...this list will need to be adjusted depending on the exact nature of the fitting we are doing
# for both recruitment & fishing is best done as lognormal.

R.mean <- log(100) # recruitment
R.sd <- 1
Im.mean <- log(10) #immigration
Im.sd <- 1
F.mean <- log(0.25) # fishing
F.sd <- 0.01
error.mean = 2 # process error shape
error.sd = 1 # process error scale

Names <- c(paste0("r",c(0:dim(fishtotal)[2])), "Im",'F','error') # for now assume one burn-in recruitment rate, three years of observations, and one harvest rate, and one process error term

Means <- c(rep(R.mean,dim(fishtotal)[2]+1), Im.mean ,F.mean,error.mean) #can't have negative fishing or recruitment
SDs <- c(rep(R.sd,dim(fishtotal)[2]+1), Im.sd,F.sd,error.sd)
# Type <- rep('lognormal', length(Means))
Type <- c(rep('lognormal',dim(fishtotal)[2]+1), "lognormal",
          "lognormal", "invgamma") #type for recruitment, immigration, fishing, and process error

Prior <- list(Names,Means,SDs,Type)
names(Prior) <- c('Names','Means','SDs','Type')
```

```{r}
# Setup things for fitting via MCMC
Fit <- fit.SSIPM.MCMC(fix.param,fishtotal,Prior,'mc_str_ar_P_A.RData', burnin = FALSE)
# save the results...

```

```{r}
#post-processing the chains (work in progress)
Post.fit <- postproc.MCMC(Fit) # combine chains & do diagnostic checks

```

```{r}
# Examine the prior
hist(Post.fit$Values[,"Im"])

#Estimated MCMC vaues by chain
ggplot()+
  geom_line(data = data.frame(Post.fit), aes(y = PosteriorProb, x = c(1:length(Post.fit$PosteriorProb))), color = "red")+
  geom_vline(xintercept = 5000, linetype = "dashed")+
  xlim(100005, length(Post.fit$PosteriorProb))+
  ylim(min(Post.fit$PosteriorProb[c(100000:150003)]),max(Post.fit$PosteriorProb))

plot(Post.fit$PosteriorProb)

```

```{r}
#Posterior predictive checks (still in progress)
```


### Plots
```{r plot IPM vs BK size distribution}
#### BK size distribution
bk_size <- songs %>% #USING ONLY Phase 1 data
  mutate(species_code = as_factor(factor(species_code,   #reorder the factors
 levels = c( "SEPU","PACL","PANE","EMJA","CHPU","OXCA"))),
total_length = as.numeric(total_length), #change length to numeric
         reef_code = as_factor(reef_code),
         year = as.factor(year)) %>%   
filter( reef_code == "BK") %>% 
  summarise(count = sum(count), 
            .by = c(year,total_length, species_code, reef_code, transect_code,total_area_sampled)) %>%     #sum the count through the years
  uncount(count) %>%                   #reorder so each row = 1 count
  relocate(year, species_code,reef_code,transect_code, total_length, total_area_sampled) %>%  #reorder df order
  mutate(count = 1) #make a column so each row has one value


### stable state distribution
     im.cand.param <-  c( rep(1,51), 0, 0.25 ,0) 
      names(im.cand.param) <- c(paste0("r",c(0:50)), "Im", 'F', 'error')
      im.data <- fishtotal #data
      im.data[,c(1:50)] <- NA #not reliant on data but use df structure
      im.ipm <- run.IPM(fix.param, im.cand.param, im.data, burnin.im = FALSE, ipm.im = FALSE)
      # stbstate <- im.ipm$N[,50] # Distant future based on IPM
stb <- data.frame(stbstate)
im.ipm <- data.frame(stb) %>% add_column("total_length" = 1:length(stbstate)) %>% 
  mutate(total_length = total_length*fix.param$dx)
  # mutate(stbstate = if_else(total_length<9,0,stbstate))

#graph
p.sepu <-  ggplot()+
  geom_density(bk_size %>% filter( species_code%in% "SEPU")%>%
                 mutate(year = as_factor(year)),    #data
              mapping = aes(x = total_length, fill = year))+   #use densiity plot
   geom_line(im.ipm, mapping = aes( x = total_length, y = stbstate), color = "hotpink")+
  facet_wrap(~year, ncol = 1, scales = "free_y")+    #separate plots by species
  scale_x_continuous(breaks = seq(0,75, 10),
                     limits = c(0,75))+  #scale x to be max length
  # scale_y_continuous(breaks = seq(0,0.1, 0.08),
  #                    limits = c(0,0.1))+ #scale y tick mark
  labs(x = "Total Length (mm)",    #edit axis & legend labels
       y = "Density",
       fill = "Year",
       title = element_text("BK sepu"))+
  scale_fill_viridis_d()+  #color palatte
  theme_classic()+
  theme(panel.background = element_rect(fill = "grey96", color = "black"),
        plot.title = element_text(hjust = 0.5),
        panel.spacing = unit(1, "mm"),
        strip.text = element_blank(),
        legend.position = "none")+
   geom_text(bk_size %>% filter(species_code%in% "SEPU"),mapping = aes(x = 75, y = 0.05, label = year))

# (p.sepu + p.pacl + p.pane)/(p.emja + p.chpu + p.oxca) +
#   plot_layout(guides = "collect") &
#   xlim(0,60)
  

```